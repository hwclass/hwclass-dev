---
title: Sunucu-taraflÄ± React Componentâ€™leri ve Streamâ€™ler
date: '2021-01-20'
---

![](https://miro.medium.com/max/1400/1*2EKuojUPUs0MG9Z7XUc0hg.png)

Bundan birkaÃ§ sene Ã¶nce componentâ€™lerin cloud ortamÄ±ndan servis edilmesine dair bir [yazÄ±](https://codeburst.io/aws-rendered-react-chocolate-chips-with-dawson-part-1-a-simple-service-for-serving-components-2b47a87bebab) Ã¼zerinden kÃ¼Ã§Ã¼k bir deneme yapmÄ±ÅŸtÄ±m. Temelde lambda fonksiyonlarÄ± halinde organize edilmiÅŸ UI componentâ€™lerinin hem bundle costâ€™unu minimuma Ã§ekerek render edebilmek, buradan da cloudâ€™ta decouple edilmiÅŸ client iÅŸlem parÃ§alarÄ±nÄ± HTML iÃ§eren stringâ€™ler olarak farklÄ± uygulamalara embed edebilmekten bahsettiÄŸim yazÄ±da, o zamanlar yeni yeni serpilen IaC (infrastructure as code) aracÄ± olan ve gÃ¼nÃ¼mÃ¼zde [serverless](https://www.serverless.com/)â€™Ä±n bir muadili olma niyetindeki [dawson](https://github.com/dawson-org) adlÄ± bir library kullanmÄ±ÅŸtÄ±m. BÃ¶ylece SSR yanÄ±nda bedava gelen First Contentful Paint ve / veya Largest Contentful Paint gibi parametrelerin sÃ¼relerini azaltmak istemiÅŸtim.

[

AWS-rendered React chocolate chips with Dawsonâ€” Part 1: A simple service for serving components
-----------------------------------------------------------------------------------------------

### For a while, Iâ€™ve been searching for the alternative methods for having components or page fragments independently fromâ€¦

codeburst.io

](https://codeburst.io/aws-rendered-react-chocolate-chips-with-dawson-part-1-a-simple-service-for-serving-components-2b47a87bebab)

Haber uygulamalarÄ±ndaki anlÄ±k widgetâ€™larÄ± (dolar kuru, hava durumu, vb.) referans alarak biraz zaman harcamÄ±ÅŸtÄ±m. AklÄ±mdakini tam olarak uygulamÄ±ÅŸ olsam da, bu tÃ¼r bir metodun clientâ€™taki stateâ€™in durumunu bozmadan, embed edilen uygulama iÃ§erisinde uyumlu ÅŸekilde run edilebilmesi iÅŸi iÃ§in componentâ€™leri render ederken atanmÄ±ÅŸ eventâ€™leri varsa onlarÄ± korumak ve componentâ€™ler arasÄ± iletiÅŸim Ã¼zerine kafa yoramamÄ±ÅŸtÄ±m.

GeÃ§tiÄŸimiz ay, React Server Components Ã¼zerine Ã§alÄ±ÅŸÄ±ldÄ±ÄŸÄ±nÄ± farkettiÄŸimde acaba ne yapÄ±lmak isteniyor diye Ã§ok merak ettim ve kod ile gÃ¼nÃ¼mÃ¼z uygulamalarÄ±na nasÄ±l entegre edilebileceÄŸini biraz araÅŸtÄ±rdÄ±m. TanÄ±tÄ±m videosu ve demo ile [birkaÃ§](https://ahmadawais.com/react-server-components/) blog [post](https://addyosmani.com/blog/react-server-components/)â€™ta yaptÄ±ÄŸÄ±m gezinti bana bazÄ± konularda yeni ÅŸeyler Ã¶ÄŸrenmemin de kapÄ±sÄ±nÄ± aralamÄ±ÅŸ oldum ve bunu paylaÅŸmak istedim.

![](https://miro.medium.com/max/1400/1*VoafdxQtOF7dfr1DjGyVKw.png)[https://twitter.com/reactjs/status/1341072021099327489](https://twitter.com/reactjs/status/1341072021099327489)[

reactjs/rfcs
------------

### âš ï¸ NOTE: We strongly recommend watching our talk introducing Server Components before reading this RFC. âš ï¸ NOTE: Weâ€¦

github.com

](https://github.com/reactjs/rfcs/blob/2b3ab544f46f74b9035d7768c143dc2efbacedb6/text/0000-server-components.md)

AttÄ±klarÄ± [tweet](https://twitter.com/reactjs/status/1341072021099327489?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed&ref_url=notion%3A%2F%2Fwww.notion.so%2Fhwclass%2Fcf6b5186782045dc9afcd3732296a766%3Fv%3D410bfc5f8e28423489cb525625d66bac%26p%3D899285bed4f44d9299f9597f65bb85e7) ile duyurduklarÄ± [blog post](https://reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html)â€™larÄ±nda ve [RFC](https://github.com/reactjs/rfcs/blob/2b3ab544f46f74b9035d7768c143dc2efbacedb6/text/0000-server-components.md) Ã¼zerinden kabaca bir gÃ¶zattÄ±ÄŸÄ±mda React componentâ€™lerini bir nevi sunucudan servis etmek Ã¼zerine kurulu bir stratejisi olduÄŸu anlaÅŸÄ±lÄ±yordu. React kodunun sunucuda execute edilip iÃ§ermek istenilen veri ile istemciye sunulmasÄ± demek. Temelde ise Ã§Ã¶zmek istenen sorun, request waterfall problemi. Bunu da birbiri iÃ§erisine geÃ§miÅŸ componentâ€™lerin bir ÅŸekilde baÄŸÄ±mlÄ± olduklarÄ± veriyi waterfall sÄ±rasÄ±na client Ã¼zerinde sokmadan, clientâ€™a sunucundan ilgili React componentâ€™in veri ile birlikte HTML Ã§Ä±ktÄ±sÄ± halinde alabilmeyi amaÃ§lÄ±yor.

AslÄ±nda tek Ã§Ã¶zmek istediÄŸi bu deÄŸil. Ä°Ã§i iÃ§ine geÃ§miÅŸ React componentâ€™leri aynÄ± zamanda baÅŸka destekleyici kÃ¼tÃ¼phanlerdeki iÅŸlevleri de iÃ§ermeleri sÃ¶z konusu. Bu istemcide yÃ¼klenecek olan bundle boyutunun bÃ¼yÃ¼mesi demek.

> [Server Components run only on the server and have zero impact on bundle-size. Their code is never downloaded to clients, helping to reduce bundle sizes and improve startup time.](https://github.com/reactjs/rfcs/blob/2b3ab544f46f74b9035d7768c143dc2efbacedb6/text/0000-server-components.md#summary)

React ekibi (anlaÅŸÄ±ldÄ±ÄŸÄ± kadarÄ±yla) Reactiâ€™i ES Modulesâ€™e uyumlu hale getirmek yerine, Ã§Ä±ktÄ± kodunu kÃ¼Ã§Ã¼ltecek alternatif bir yol benimseyerek (date picker, date/time conversion ya da uluslararasÄ±laÅŸtÄ±rma (i18n) veyahut lokalleÅŸtirme (l10n) gibi iÅŸlevselliklerin Ã§Ã¶zÃ¼mÃ¼nde tercih edilebileceÄŸini dÃ¼ÅŸÃ¼ndÃ¼ÄŸÃ¼m) ek kÃ¼tÃ¼phanelerin kod Ã§Ä±ktÄ±sÄ±nda yaratacaÄŸÄ± yÃ¼kÃ¼ azaltmayÄ± da dÃ¼ÅŸÃ¼nÃ¼yor. BÃ¶ylece kod direk olarak sunucuda iÅŸleneceÄŸi ve transpile edilerek belli bir formatta (buna sonra deÄŸineceÄŸiz) clientâ€™a geri gÃ¶nderileceÄŸinden sÄ±fÄ±r-baÄŸÄ±mlÄ±lÄ±k gibi bir kazancÄ± da saÄŸlamasÄ±, kodun browserâ€™da execute edilmesini de hÄ±zlandÄ±racaÄŸÄ± dÃ¼ÅŸÃ¼nÃ¼lmÃ¼ÅŸ. Ek olarak, sunucuda (herhangi bir remote kaynaÄŸa) yapÄ±lacak bir requestâ€™in clientâ€™ta yapÄ±lacak bir requestâ€™ten daha hÄ±zlÄ± sonuÃ§ vereceÄŸi Ã¶n kabulÃ¼nden hareketle istemcide kodun yÃ¼klenme sÃ¼ratinden de bir kazanÃ§ ortaya Ã§Ä±kacaÄŸÄ±nÄ± dÃ¼ÅŸÃ¼nebiliriz.

![](https://miro.medium.com/max/1400/1*rEYAa5oRMJjltp3Yb7N8Uw.png)

React Server Components ile kod organizasyonunda da birkaÃ§ deÄŸiÅŸikliÄŸe gidilmesi planlanmÄ±ÅŸ. Buna gÃ¶re, clientâ€™a serve edilecek componentâ€™lerin dosya isimleri **ComponentName.client.js**, sunucudaâ€™kilerin ise **ComponentName.server.js** oluyor. BunlarÄ±n yanÄ± sÄ±ra, her iki kÄ±sÄ±mda da kullanÄ±labilecek ortak/shared componentâ€™ler tanÄ±mlanabiliyor. Propâ€™lar Ã¼zerinden aralarÄ±ndaki â€œ_top-to-down_â€ veri aktarÄ±mÄ± ise serializable olan her veri tipi iÃ§in geÃ§erli, aksi durum networkte macerasÄ±na baÅŸlayan requestâ€™in iÅŸlenmesi iÃ§in mÃ¼mkÃ¼n olmayan bir durum, zira videodaki Ã¶rnekte de (Ã¶rneÄŸin) bir fonksiyonun prop olarak kullanÄ±lamayacaÄŸÄ± belirtilmiÅŸ. Ã–zetle, HTTP isteÄŸiniz ile response olarak ilgili client componentâ€™inize property olarak paslayacaÄŸÄ±nÄ±z her ne ise bu (Ã¶rneÄŸin) bir javascript fonksiyonu olamÄ±yor:

![](https://miro.medium.com/max/1400/1*zLb_B0E-Jtq51cnVzzbi4A.png)

Bu Ã¶rneÄŸin karÅŸÄ±sÄ±na ise, sunucudan geri gÃ¶nderilen response Ã¼zerinde serialize edilebilen JSXâ€™i gÃ¶ndermeyi koymuÅŸlar. Bu da JSX kodunun React Server Componentâ€™inin clientâ€™a response gÃ¶nderilmeden Ã¶nce render edilmesi ve Ã¶yle gÃ¶nderilmesi anlamÄ±na geliyor.

Bu noktada, React Server Components aslÄ±nda JSXâ€™in sunucu-taraflÄ± render edilmesi yerine, daha baÅŸka bir formatta, clientâ€™taki component aÄŸacÄ±nÄ± client stateâ€™ini bozmadan clientâ€™a aktarmayi saÄŸlayan bir ara birime dÃ¶nÃ¼ÅŸÃ¼yor. Yani bir taraftan clientâ€™taki componentâ€™leriniz sorunsuz ÅŸekilde Ã§alÄ±ÅŸmaya devam ederken server componentâ€™inizden gelecek Ã§Ä±ktÄ± ile uygulamanÄ±zda browserâ€™Ä±n refresh edilmesi gibi bir sorun olmuyor Ã§Ã¼nkÃ¼ sadece sunucudan gelen sonuÃ§ (component ve data) ile uygulamanÄ±n sadece kÄ±smen gÃ¼ncellenmesi saÄŸlanÄ±yor ve geri kalanÄ± aynÄ± kalabiliyor. Sunum videosunda RSC ile SSRâ€™Ä±n birbirinden ayrÄ± ama birlikte kullanabilecek uyumlu konseptler olduÄŸundan da bahsediliyor. Buna ek olarak, sunucuda varolan bir dosyanÄ±n iÃ§eriÄŸinin yine sunucuda okunup server componentâ€™inin JSX aÄŸacÄ±na embed edilerek render edilip clientâ€™a gÃ¶nderilmesi gibi bir use-case de anlatÄ±lmÄ±ÅŸ.

Bu fikrin ilginÃ§ baÅŸka bir yanÄ± ise React Server Componentâ€™lerini Next.js ve Nuxt gibi hibrit geliÅŸtirme araÃ§larÄ±nÄ±n temelde yaptÄ±ÄŸÄ± rehydrating iÅŸleminin sadece React kullanÄ±larak (bir nevi farklÄ± bir format ve yÃ¶ntem kullanarak) ortaya konabilen versiyonlarÄ± olmalarÄ±. Ã–rneÄŸin, Next.js ile sunucudan alÄ±nmÄ±ÅŸ bir verinin bÃ¼tÃ¼n sayfa yenilenmeden DOM aÄŸacÄ±nÄ±n yenilenerek ve React componentâ€™lerinin aynÄ± ÅŸekilde iÅŸlemeye devam etmesini saÄŸlayabiliyoruz. Buna yardÄ±mcÄ± olarak Nextâ€™in Ã¶nemli Ã¶lÃ§Ã¼de ([getInitialProps](https://nextjs.org/docs/api-reference/data-fetching/getInitialProps) aracÄ±lÄ±ÄŸÄ±yla) clientâ€™ta update ettiÄŸi ve HTMLâ€™e gÃ¶mÃ¼lmÃ¼ÅŸ bir karakterize-JSONâ€™dan (stringified ceysÄ±n ğŸ”ª) faydalanÄ±lÄ±yor. Bu da aynÄ± anda, hem sunucunun Ã¼zerinde render edilmiÅŸ sayfalarÄ±n SEO ihtiyaÃ§larÄ±nÄ±n karÅŸÄ±lanmasÄ± sÃ¶z konusuyken, bir taraftan da istemcideki uygulama akÄ±ÅŸÄ±nÄ±n da bozulmamasÄ± anlamÄ±na geliyordu. Bunun yanÄ±sÄ±ra bu konuda Next.js ile React Server Componentsâ€™Ä±n ayrÄ±ÅŸtÄ±ÄŸÄ± noktalarÄ± [ÅŸuradan](https://news.ycombinator.com/item?id=25499171) genel olarak Ã¶ÄŸrenebildim, faydalÄ± oldu ve merakÄ±m giderek arttÄ±. Bir gÃ¶z atmanÄ±zÄ± tavsiye ederim.

BÃ¼tÃ¼n bu detaylar Ä±ÅŸÄ±ÄŸÄ±nda merakÄ±m iyice arttÄ± ve kodun iÃ§erisine girip daha iyi anlamak istedim. UygulamalarÄ± analiz etmeye Ã§alÄ±ÅŸtÄ±ÄŸÄ±mda ilk baktÄ±ÄŸÄ±m detay / nokta genelde sunucu ile nasÄ±l iletiÅŸime girdiÄŸi ve burada nasÄ±l bir yol izlendiÄŸi oluyor. Bunun belli baÅŸlÄ± sebepleri var ve Ã§ok detaya girmeden ÅŸunu diyebilirim ki, bir uygulamanÄ±n veri alÄ±ÅŸveriÅŸi iÃ§in sahip olduÄŸu iletiÅŸim modeli, o uygulamanÄ±n ne iÃ§in ya da nasÄ±l geliÅŸtirildiÄŸini anlattÄ±ÄŸÄ±nÄ± dÃ¼ÅŸÃ¼nÃ¼yorum. AnlÄ±k ya da deÄŸil, event bazlÄ± ya da deÄŸil ve daha birÃ§oÄŸu. Burada da deÄŸindiÄŸin detay, bir chat ya da notification featureâ€™Ä± iÃ§eren bir uygulamayÄ± tasarlamanÄ±z ile statik export ile sadece dinamik routing nitelikleri kazandÄ±rmanÄ±zÄ±n yeterli olduÄŸu uygulamalar arasÄ±ndaki farklar gibi ve benzeri. Ã–zellikle gÃ¼n iÃ§erisinde iÅŸinize odaklanmÄ±ÅŸken Ã¶nÃ¼nÃ¼zdeki uygulamayÄ± anlamaya Ã§alÄ±ÅŸÄ±yorsanÄ±z, legacy uygulamalarÄ±n en leÅŸ kÄ±sÄ±mlarÄ±na bug fix yapmanÄ±z gerektiyse / gerekiyorsa ya da system design [konularÄ±na](https://www.wikiwand.com/en/Back-of-the-envelope_calculation) merakÄ±nÄ±z varsa, bÃ¼yÃ¼k bir ihtimalle sizin de kendinize has yÃ¶ntemleriniz vardÄ±r. Bu da sadece onlardan birisi.

O nedenle, ben de RSC demo uygulamasÄ±nÄ± lokalde run ettiÄŸimde gidip baktÄ±ÄŸÄ±m ilk yer burasÄ±ydÄ±. Uygulama ile girdiÄŸim ilk iletiÅŸimde yaptÄ±ÄŸÄ±m bir deÄŸiÅŸikliÄŸin akabinde sunucu kÄ±smÄ±yla nasÄ±l konuÅŸtuÄŸuna bakmakla incelememe baÅŸlamÄ±ÅŸtÄ±m. Buna gÃ¶re; uygulamada sol paneldeki her bir farklÄ± itemâ€™Ä±n seÃ§ilmesiyle â€œ_/react_â€ endpointâ€™ine bir request yapÄ±lÄ±yor. O anki state ise bir query stringâ€™e populate ediliyordu:

![](https://miro.medium.com/max/1400/1*vU6Kw3r2hFgts6jmDw8erQ.png)

Bu endpointâ€™e gidip gelen her bir request/responseâ€™ta da aÅŸaÄŸÄ±daki gibi bir custom header update oluyor.

```
X-Location: {â€œselectedIdâ€:4,â€isEditingâ€:false,â€searchTextâ€:â€aâ€}
```

APIâ€™yi run eden bir [express](https://expressjs.com/) sunucusu ise HTTP endpoint callbackâ€™i Ã¼zerinden bunu yakalÄ±yor ve requestâ€™in iÃ§eriÄŸini sendResponse metoduna delege ediyor:

![](https://miro.medium.com/max/1400/1*txmzm3mcxCVA_h_2S07l_w.png)[https://github.com/reactjs/server-components-demo/blob/4ecf1f2641ecc822fe8f933ac3cd23f4ed4629d7/server/api.server.js#L92](https://github.com/reactjs/server-components-demo/blob/4ecf1f2641ecc822fe8f933ac3cd23f4ed4629d7/server/api.server.js#L92)

Dikkat ederseniz, sendResponse metodunun 3. argÃ¼manÄ± null. Normal ÅŸartlarda bu argÃ¼man â€œselectedIdâ€ olarak set edilmiÅŸ biÃ§imde sadece tek bir POST requestâ€™inde (/notes) gÃ¶nderiliyor. Sebebi ise sunucudan React treeâ€™si render edilip geri clientâ€™a (id ve chunk urlâ€™lerinden oluÅŸan bir JSON mapâ€™i olarak) dÃ¶ndÃ¼rÃ¼lÃ¼rken varolan stateâ€™i orada da korumak. Bu response alÄ±nÄ±nca client tarafÄ±nda bu â€œselectedIdâ€ okunuyor. Detaylar geliyorâ€¦

BÃ¼tÃ¼n bunlara ek olarak, uygulamayÄ± browserâ€™da execute edecek kÄ±sÄ±mlarÄ± bulmaya Ã§alÄ±ÅŸtÄ±ÄŸÄ±mda package.jsonâ€™dan uygulamayÄ± bundleâ€™a export eden [satÄ±rlar](https://github.com/reactjs/server-components-demo/blob/main/package.json#L45)Ä±n build.jsâ€™i run ettiÄŸi yeri buldum. O da entry olarak [index.client.js](https://github.com/reactjs/server-components-demo/blob/main/scripts/build.js#L23)â€™i iÅŸaret ediyor. ArdÄ±ndan dosya iÃ§erisine import edilen [Root.client.js](https://github.com/reactjs/server-components-demo/blob/main/src/Root.client.js)â€™teki [Root componentâ€™i](https://github.com/reactjs/server-components-demo/blob/main/src/Root.client.js#L15)ni render ediyor. O da aynÄ± dosyadaki ve LocationContext.Provider ile wrap edilmiÅŸ ve Rootâ€™un iÃ§eriÄŸini update eden [Content componentâ€™i](https://github.com/reactjs/server-components-demo/blob/main/src/Root.client.js#L25)ni kullanÄ±yor. UygulamanÄ±n tamamÄ± bu arkadaÅŸÄ±n saÄŸladÄ±ÄŸÄ± iÃ§erikten render oluyor diyebiliriz.

![](https://miro.medium.com/max/1400/1*TxMGaQQkdSIV2e7RRpl8YQ.png)[https://github.com/reactjs/server-components-demo/blob/3a505efea0b1191496a832e23f3de46a0db69915/src/Root.client.js#L25](https://github.com/reactjs/server-components-demo/blob/3a505efea0b1191496a832e23f3de46a0db69915/src/Root.client.js#L25)

Åimdi ana akÄ±ÅŸÄ± bozmadan devam edelim ve sunucu tarafÄ±nda â€œ/reactâ€ endpointâ€™inde execute edilen [sendResponse](https://github.com/reactjs/server-components-demo/blob/4ecf1f2641ecc822fe8f933ac3cd23f4ed4629d7/server/api.server.js#L79) fonksiyonunu inceleyelim. Bu fonksiyon aslÄ±nda bir [decorator](https://www.wikiwand.com/en/Decorator_pattern) gibi Ã§alÄ±ÅŸÄ±yor ve o anda alÄ±nan requestâ€™in durumuna gÃ¶re responseâ€™un iÃ§eriÄŸini â€œdekore ediyorâ€ / belirliyor. YukarÄ±da bahsettiÄŸimiz o anki client stateâ€™ini location query stringâ€™inden alÄ±yor ve responseâ€™un headerâ€™Ä±ndaki X-Location olarak set ediyor. EÄŸer 3. argÃ¼man null deÄŸilse selectedIdâ€™ye set ediyor ve son aÅŸama olarak renderReactTree metodunu Ã§aÄŸÄ±rÄ±yor.

![](https://miro.medium.com/max/1400/1*zAK4neejB7cOFrA8kuYZ8Q.png)[https://github.com/reactjs/server-components-demo/blob/4ecf1f2641ecc822fe8f933ac3cd23f4ed4629d7/server/api.server.js#L79](https://github.com/reactjs/server-components-demo/blob/4ecf1f2641ecc822fe8f933ac3cd23f4ed4629d7/server/api.server.js#L79)

[renderReactTree](https://github.com/reactjs/server-components-demo/blob/4ecf1f2641ecc822fe8f933ac3cd23f4ed4629d7/server/api.server.js#L69) metodu, asenkron [waitForWebpack](https://github.com/reactjs/server-components-demo/blob/4ecf1f2641ecc822fe8f933ac3cd23f4ed4629d7/server/api.server.js#L70) fonksiyonunun sonlanmasÄ±nÄ± bekleyip en baÅŸta run edilen build commandâ€™inin export ettiÄŸi bir manifest (_./build/react-client-manifest.json_) dosyasÄ±ndaki iÃ§eriÄŸi bir deÄŸiÅŸkene (moduleMap) set ediyor:

![](https://miro.medium.com/max/1400/1*58q4bJYhqah9FxYx7qFj5g.png)[https://github.com/reactjs/server-components-demo/blob/4ecf1f2641ecc822fe8f933ac3cd23f4ed4629d7/server/api.server.js#L71](https://github.com/reactjs/server-components-demo/blob/4ecf1f2641ecc822fe8f933ac3cd23f4ed4629d7/server/api.server.js#L71)

moduleMap deÄŸiÅŸkeninin iÃ§eriÄŸi ise sadece client componentâ€™lerinin meta bilgisini iÃ§eren bir [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) setâ€™i:

![](https://miro.medium.com/max/1400/1*qwGDDPuA8syNOtEM1OknMw.png)Her bir map kÄ±rÄ±lÄ±mÄ±nÄ±n bir client componentâ€™ine denk geldiÄŸi gÃ¶zlerden kaÃ§madÄ±!

Responseâ€™un clientâ€™a gÃ¶nderilmeden Ã¶nceki aÅŸama ise App.server.jsâ€™te oluÅŸturulmuÅŸ bÃ¼tÃ¼n bir React treeâ€™sinin eski/yeni veya update edilmiÅŸ / edilmemiÅŸ propâ€™lar ile manifestâ€™e (moduleMap) gÃ¶re yeniden oluÅŸturulmasÄ± aÅŸamasÄ±.

![](https://miro.medium.com/max/1400/1*8xYqZs2H4eaaNUbBzC0LYQ.png)[https://github.com/facebook/react/blob/master/packages/react-server-dom-webpack/package.json#L28](https://github.com/facebook/react/blob/master/packages/react-server-dom-webpack/package.json#L28)

[pipeToNodeWritable](https://github.com/reactjs/server-components-demo/blob/4ecf1f2641ecc822fe8f933ac3cd23f4ed4629d7/server/api.server.js#L25) metodu react-dom-server-webpack packageâ€™Ä±nÄ±n [iÃ§erisindeki](https://github.com/facebook/react/blob/master/packages/react-server-dom-webpack/package.json#L28) writer aliasâ€™Ä±ndan geliyor. Bu da sunucuda run olan ReactFlightDOMServerNode.js dosyasÄ±na refere ediyor. Kaynak koddan gÃ¶rÃ¼leceÄŸi gibi, pipeToNodeWritable metodu 3 argÃ¼man alacak ve herhangi bir dÃ¶nÃ¼ÅŸ deÄŸeri bulunmayacak ÅŸekilde organize edilmiÅŸ:

![](https://miro.medium.com/max/1400/1*Z8hkZetcur40l_IFN9p3Fg.png)![](https://miro.medium.com/max/1400/1*aAhLSL6z9DR2bcCHLFOMvw.png)[https://github.com/facebook/react/blob/master/packages/react-server-dom-webpack/src/ReactFlightServerWebpackBundlerConfig.js](https://github.com/facebook/react/blob/master/packages/react-server-dom-webpack/src/ReactFlightServerWebpackBundlerConfig.js)

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ Ã¼zere, manifest dosyasÄ±nÄ±n iÃ§eriÄŸi Ã¶zelde webpackâ€™in bundle edeceÄŸi kodu da update edecek bir [referans noktasÄ±](https://github.com/facebook/react/blob/master/packages/react-server-dom-webpack/src/ReactFlightServerWebpackBundlerConfig.js).

pipeToNodeWritableâ€™a gÃ¶nderilen ReactModel, Writable ve BundlerConfig tiplerindeki model, destination ve webpackMap argÃ¼manlarÄ±yla bu sefer [createRequest](https://github.com/facebook/react/blob/b99ac3d6dffbe57f94d368cc4f4e0ddf089e4f53/packages/react-server/src/ReactFlightServer.js#L92) (react-server/src/ReactFlightServer.js) Ã§aÄŸÄ±rÄ±lÄ±yor. Bu metod ise kendi iÃ§erisinde bu deÄŸerleri kullanarak [createSegment](https://github.com/facebook/react/blob/b99ac3d6dffbe57f94d368cc4f4e0ddf089e4f53/packages/react-server/src/ReactFlightServer.js#L183) isimli bir fonksiyonu Ã§aÄŸÄ±rÄ±yor ve geriye ÅŸu aÅŸaÄŸÄ±daki objeyi dÃ¶ndÃ¼rÃ¼yor:

![](https://miro.medium.com/max/1400/1*r8wgzwCTKdZrs0xg7Dhhvg.png)[https://github.com/facebook/react/blob/b99ac3d6dffbe57f94d368cc4f4e0ddf089e4f53/packages/react-server/src/ReactFlightServer.js#L183](https://github.com/facebook/react/blob/b99ac3d6dffbe57f94d368cc4f4e0ddf089e4f53/packages/react-server/src/ReactFlightServer.js#L183)

Manifest dosyasÄ± iÃ§erisinde yer alan objenin her bir elemanÄ± iÃ§in, request aÅŸaÄŸÄ±daki gibi bir request deÄŸiÅŸkenine assign edilerek oluÅŸturuluyor ve pipeToNodeWritable metoduna geri dÃ¶ndÃ¼rÃ¼lÃ¼yor:

![](https://miro.medium.com/max/1400/1*ZNH7W0OLAgkHPk2RYt2lHQ.png)[https://github.com/facebook/react/blob/b99ac3d6dffbe57f94d368cc4f4e0ddf089e4f53/packages/react-server/src/ReactFlightServer.js#L74](https://github.com/facebook/react/blob/b99ac3d6dffbe57f94d368cc4f4e0ddf089e4f53/packages/react-server/src/ReactFlightServer.js#L74)

Tam da bu noktada ilginÃ§ bir hamle geliyor ve pingedSegments dizisine ÅŸu ÅŸekilde push ediliyor:

![](https://miro.medium.com/max/1400/1*8pS0mUg8SEmJwna0vsYCrA.png)[https://github.com/facebook/react/blob/b99ac3d6dffbe57f94d368cc4f4e0ddf089e4f53/packages/react-server/src/ReactFlightServer.js#L117](https://github.com/facebook/react/blob/b99ac3d6dffbe57f94d368cc4f4e0ddf089e4f53/packages/react-server/src/ReactFlightServer.js#L117)

Yani aslÄ±nda request.pingedSegments burada Segment tipinde objelerin store edildiÄŸi bir dizi:

![](https://miro.medium.com/max/1204/1*o6tdOPZdYR2UFRhnlFGmqw.png)[https://github.com/facebook/react/blob/b99ac3d6dffbe57f94d368cc4f4e0ddf089e4f53/packages/react-server/src/ReactFlightServer.js#L68](https://github.com/facebook/react/blob/b99ac3d6dffbe57f94d368cc4f4e0ddf089e4f53/packages/react-server/src/ReactFlightServer.js#L68)

Her bir createSegment fonksiyon callâ€™u ise pingSegment adÄ±nda baÅŸka bir metod Ã§aÄŸÄ±rÄ±yor. Bu metod ise o anda henÃ¼z iÃ§i doldurulmaya baÅŸlanmÄ±ÅŸ request objesinin pingedSegments dizisine her yeni gelen segmentâ€™leri push ediyor. Segmentlerin tam olarak ne olduklarÄ±na az sonra bakacaÄŸÄ±z:

![](https://miro.medium.com/max/1400/1*IuYMWy0bdOFOgTn85SdC3g.png)[https://github.com/facebook/react/blob/b99ac3d6dffbe57f94d368cc4f4e0ddf089e4f53/packages/react-server/src/ReactFlightServer.js#L175](https://github.com/facebook/react/blob/b99ac3d6dffbe57f94d368cc4f4e0ddf089e4f53/packages/react-server/src/ReactFlightServer.js#L175)

Buradaki [performWork](https://github.com/facebook/react/blob/b99ac3d6dffbe57f94d368cc4f4e0ddf089e4f53/packages/react-server/src/ReactFlightServer.js#L665) fonksiyonuna bir bakmak faydalÄ± olabilir. Ä°Ã§eriÄŸine Ã§ok girmeden, bu fonksiyon temelde pingedSegment metodunun populate ettiÄŸi pingedSegments arrayâ€™inin iÃ§eriÄŸinin en primitif noktasÄ±na denk geliyor. Yani aslÄ±nda segmentâ€™ler, React componentâ€™lerinin Ã¶zel bir notasyonda oluÅŸturulmuÅŸ halleri. AÅŸaÄŸÄ±daki kod bloÄŸundan da gÃ¶rÃ¼leceÄŸi Ã¼zere, Ã¶nce [retrySegment](https://github.com/facebook/react/blob/b99ac3d6dffbe57f94d368cc4f4e0ddf089e4f53/packages/react-server/src/ReactFlightServer.js#L627) kendisine argÃ¼man olarak gÃ¶nderilmiÅŸ segmentin gerÃ§ekten bir React component olup olmadÄ±ÄŸÄ±nÄ± kontrol ediyor.

![](https://miro.medium.com/max/1400/1*dS-9ClN-qgpC32LnOaxvJg.png)[https://github.com/facebook/react/blob/b99ac3d6dffbe57f94d368cc4f4e0ddf089e4f53/packages/react-server/src/ReactFlightServer.js#L392](https://github.com/facebook/react/blob/b99ac3d6dffbe57f94d368cc4f4e0ddf089e4f53/packages/react-server/src/ReactFlightServer.js#L392)

ve eÄŸer Ã¶yleyse bu iÃ§eriÄŸi processModelChunkâ€™tan dÃ¶nen sonuÃ§ ile completedJSONChunks iÃ§erisine pushâ€™luyor:

![](https://miro.medium.com/max/1400/1*WieUKhzQMLlk-OWO8KSzCw.png)[https://github.com/facebook/react/blob/b99ac3d6dffbe57f94d368cc4f4e0ddf089e4f53/packages/react-server/src/ReactFlightServer.js#L650](https://github.com/facebook/react/blob/b99ac3d6dffbe57f94d368cc4f4e0ddf089e4f53/packages/react-server/src/ReactFlightServer.js#L650)

BÃ¼tÃ¼n segmentâ€™ler pushâ€™landÄ±ÄŸÄ±nda eÄŸer request.flowing deÄŸeri truthy ise request [flushCompletedChunks](https://github.com/facebook/react/blob/b99ac3d6dffbe57f94d368cc4f4e0ddf089e4f53/packages/react-server/src/ReactFlightServer.js#L686) ile destination olarak isimlendirilmiÅŸ response argÃ¼manÄ±nÄ±n iÃ§eriÄŸi streamâ€™de gÃ¶nderildiklerinde ilk olarak call edilsinler diye writeChunk metodu ile [iÅŸleniyor](https://github.com/facebook/react/blob/b99ac3d6dffbe57f94d368cc4f4e0ddf089e4f53/packages/react-server/src/ReactFlightServer.js#L701), ardÄ±ndan completedJSONChunks iÃ§eriÄŸi iÅŸleme alÄ±nÄ±yor ve pendingChunksâ€™Ä±n iÃ§eriÄŸi boÅŸaltÄ±lÄ±yor, son olarak da [completeWriting](https://github.com/facebook/react/blob/b99ac3d6dffbe57f94d368cc4f4e0ddf089e4f53/packages/react-server/src/ReactServerStreamConfigNode.js#L53) metodu Ã§aÄŸrÄ±larak clientâ€™ta geri dÃ¶ndÃ¼rÃ¼lecek olan responseâ€™un bÃ¼tÃ¼n bufferâ€™lanmÄ±ÅŸ dataâ€™sÄ± [temizleniyor](https://nodejs.org/api/stream.html#stream_writable_uncork) ve son haline kavuÅŸuyor.

![](https://miro.medium.com/max/1400/1*cBCFdk0OHe2sumy1Qp3gaw.png)

BÃ¼tÃ¼n bu eldeki veri, Transfer-Encoding response headerâ€™Ä± chunked olarak set edilip en baÅŸta anlattÄ±ÄŸÄ±mÄ±z â€œ/reactâ€ endpointinden Ã§aÄŸÄ±rÄ±lan sendResponse, ardÄ±ndan call edilen renderReactTree ve en sonunda bÃ¼tÃ¼n bir React treeâ€™sini webpack notasyonunda tekrar streamâ€™e geri dÃ¶ndÃ¼rÃ¼lmek Ã¼zere execute edilen pipeToNodeWritable Ã§aÄŸÄ±rÄ±lÄ±yor ve client kÄ±sÄ±mda yapÄ±lan ve sunucuyu pingâ€™leyen herhangi bir anda tekrardan build edilip yine bir stream responseâ€™u olarak clientâ€™a geri dÃ¶ndÃ¼rÃ¼lÃ¼yor. Chunkedâ€™lanmÄ±ÅŸ sunucu cevabÄ±mÄ±z ise ÅŸu ÅŸekilde oluyor:

![](https://miro.medium.com/max/1400/1*JdxDdU6jgJT1QX04rpdnMw.png)

Tam da bu noktada deÄŸinmek istediÄŸim baÅŸka bir konu daha var, o da bÃ¼tÃ¼n bu mekanizmanÄ±n Ã¼zerine kurulduÄŸu HTTP 1.1 ile uygunlamaya [sunulan](https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6.1) chunk tabanlÄ± veri alÄ±ÅŸveriÅŸini network seviyesine taÅŸÄ±yan streamâ€™ler. Bu konuyu direk olarak [Node.js Streams](https://nodejs.org/api/stream.html#stream_stream) Ã¼zerinden anlatmayÄ± tercih ettim, en nihayetinde â€œkodâ€ dilinde konuÅŸuyoruz. Streams Ã¶zellikle dosya okuma/yazma, network Ã¼zerinden iletiÅŸim gibi iÅŸlemlerin memory ve performans konusunda yarattÄ±klarÄ± sorunlardan muzdarip olanlarÄ±n tercih ettikleri bir Node.jsâ€™in featureâ€™Ä±. GerÃ§ek hayattan bir Ã¶rnek vermek gerekirse, okunup iÃ§eriÄŸi Ã¼zerinde bir transform iÅŸlemi gerÃ§ekleÅŸtirilecek olan bir dosyanÄ±n stream ile aÃ§Ä±lÄ±p okunmasÄ± daha efektif Ã§Ã¼nkÃ¼ Streams bu dataâ€™yÄ± chunkâ€™lar halinde iÅŸliyor ve her bir iÅŸlem sonrasÄ±nda hafÄ±zadan bir Ã¶nceki versiyonu/iÃ§eriÄŸi siliyor. Bunu HTTP protokolÃ¼ne uyguladÄ±ÄŸÄ±mÄ±zda Ã¶rnek verebileceÄŸim diÄŸer bir durum da video streaming.

Mesela, eÄŸer Youtube Ã¼zerinden izlediÄŸiniz bir videonun tamamÄ±nÄ±n yÃ¼klenerek gÃ¶sterildiÄŸini dÃ¼ÅŸÃ¼nÃ¼yorsanÄ±z yanÄ±lÄ±yorsunuz Ã§Ã¼nkÃ¼ bir videonun sayfasÄ±na girdiÄŸinizde ilk elden gÃ¶sterilmeye baÅŸlanmasÄ±nÄ±n sebebi, Youtubeâ€™un sunucularÄ±ndan video verisinin kÃ¼Ã§Ã¼k parÃ§alar halinde clientâ€™a servis edilmesi.

![](https://miro.medium.com/max/880/1*CJmPLbrU5Tzs9Dxgwa4X4g.gif)youtube.com -> right click on video -> Stats for nerds -> Network Activity

Konuyu biraz daha Ã¶zele inerek aÃ§alÄ±m. [Gulp](https://florian.ec/blog/gulp-js-streams/) â€˜Ä± hemen hemen herkes hatÄ±rlÄ±yordur, hatta hala kullanÄ±labilir bir tool olduÄŸunu dÃ¼ÅŸÃ¼nÃ¼yorum. Gulp da bir build toolâ€™u olduÄŸundan aslÄ±nda arka planda streamâ€™lerle Ã§alÄ±ÅŸÄ±yor. Hani ÅŸu sÄ±rasÄ±yla minify edilen bundleâ€™larÄ±nÄ±z var ya, iÅŸte onlarÄ±n hepsi Gulp Ã¼zerinde sanal olarak oluÅŸturulmuÅŸ [object streamâ€™lere](https://community.risingstack.com/the-definitive-guide-to-object-streams-in-node-js/) yazÄ±lÄ±yor ve yeri geldiÄŸinde kullanÄ±lÄ±p hafÄ±zadan siliniyor. Boyutu bÃ¼yÃ¼k olan kod dosyalarÄ±nÄ±z Ã¼zerinde bu iÅŸlemler uygulanÄ±rken tipki unix pipe (|) operatÃ¶rÃ¼ gibi bir readable streamâ€™den sonraki bir writable streamâ€™e geÃ§it aÃ§abiliyoruz.

![](https://miro.medium.com/max/1400/1*KrqJ6xk6RdRAMl5rgvx_qg.png)

Streamâ€™ler yine Node.jsâ€™in [EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter) classâ€™Ä±ndan tÃ¼retilmiÅŸ sÄ±nÄ±flar ve 4 Ã§eÅŸitten oluÅŸuyor. Verinin yazÄ±labildiÄŸi [Writable](https://nodejs.org/api/stream.html#stream_class_stream_writable), okunabildiÄŸi [Readable](https://nodejs.org/api/stream.html#stream_class_stream_readable), hem yazÄ±lÄ±p hem okunabilen [Duplex](https://nodejs.org/api/stream.html#stream_class_stream_duplex) ve Duplex streamâ€™leri iÃ§erisine hem yazÄ±lÄ±p hem okubilen verinin aynÄ± zamanda editlenebildiÄŸi [Transform](https://nodejs.org/api/stream.html#stream_class_stream_transform). Ã–rneÄŸin, Node.jsâ€™teki [request objesi](https://nodejs.org/api/http.html#http_class_http_incomingmessage) bir okunabilir stream. AynÄ± zamanda bir stream olan response objesinin kullanÄ±mÄ±ndan da gÃ¶rÃ¼leceÄŸi Ã¼zere, sanki eventâ€™ler iÃ§erisinde iÅŸlem yapÄ±yormuÅŸsunuz gibi bir his vermesinin sebebi de tam da bu, yani kendisinin EventEmitterâ€™dan tÃ¼retilmiÅŸ bir Stream olmasÄ±.

![](https://miro.medium.com/max/1400/1*SPe0qkHkTfvO2gOYcQNvVg.png)

Ã–zellikle asenkron data aktarÄ±mÄ± konusunda [yardÄ±mcÄ±](https://changelog.com/jsparty/103#transcript-30) bir Node.js featureâ€™Ä± olan Streamâ€™ler, bÃ¶ylece bir sonraki iÅŸleme geÃ§meden Ã¶nce mevcut iÅŸlemin gerÃ§ekleÅŸmesi sÄ±rasÄ±nda durdurulmasÄ± mÃ¼mkÃ¼n oluyor. React Server Components konsepti Streamâ€™lerin Ã¼zerine kurulu olduÄŸu iletiÅŸim modelinden faydalanÄ±yor. Chunk-tabanlÄ± bir istemci-sunucu networking iletiÅŸim niteliÄŸi olarak stream ile her bir deÄŸiÅŸen DOM statusâ€™Ã¼nÃ¼ sunucu tarafÄ±na gÃ¶nderip, onu sunucuda anlamlÄ± bir React tree halinde tekrar oluÅŸturup, (Ã¶rneÄŸin) veritabanÄ±nda yapÄ±lan bir deÄŸiÅŸiklik ile varolan component ve state yapÄ±sÄ±nÄ± bozmadan bir responseâ€™ta geri dÃ¶nderiyor.

KaldÄ±ÄŸÄ±mÄ±z yerden devam edecek olursak, clientâ€™a da bir gÃ¶zatmamÄ±z gerekecek. Backend tarafÄ±nda dÃ¶nen bÃ¼tÃ¼n bu hadiselerin gelip netleÅŸtiÄŸi yer client entegrasyonu. /react endpointâ€™inin call edildiÄŸi yer Cache.client.js dosyasÄ±. location keyâ€™i olmadan request yapÄ±lÄ±rsa uygulamanÄ±n React treeâ€™sini tekrardan update edilecek bir neden yok. Ancak bir location idâ€™si varsa, response react-server-dom-webpack packageâ€™i ile iÅŸlenip yeni bir bundle Ã¼retiliyor, React treeâ€™si update ediliyor.

![](https://miro.medium.com/max/1400/1*qZ53bUy2n4fKbPuhBsJlUw.png)[https://github.com/facebook/react/blob/5fd9db732dff1b99c096bffef9a565b594c788de/packages/react-server-dom-webpack/src/ReactFlightDOMClient.js#L46](https://github.com/facebook/react/blob/5fd9db732dff1b99c096bffef9a565b594c788de/packages/react-server-dom-webpack/src/ReactFlightDOMClient.js#L46)

Responseâ€™un doÄŸru bir ÅŸekilde okunup uygulamanÄ±n update edilmesi iÃ§in kullanÄ±lan readRoot fonksiyonunu saÄŸlayan ise react-server-dom-webpack pluginin [createFromFetch](https://github.com/facebook/react/blob/5fd9db732dff1b99c096bffef9a565b594c788de/packages/react-server-dom-webpack/src/ReactFlightDOMClient.js#L46) fonksiyonu. O da [startReadingFromStream](https://github.com/facebook/react/blob/5fd9db732dff1b99c096bffef9a565b594c788de/packages/react-server-dom-webpack/src/ReactFlightDOMClient.js#L52) isimli baÅŸka bir fonksiyonu Ã§aÄŸÄ±rÄ±yor. Bu fonksiyonun yaptÄ±ÄŸÄ± ise basitÃ§e bir stream reader oluÅŸturmak ve responseâ€™un iÃ§eriÄŸini okumak ve Ã§aÄŸrÄ±ldÄ±ÄŸÄ± yere geri dÃ¶ndÃ¼rmek:

![](https://miro.medium.com/max/1400/1*UfjUE8nLGvKJqgQXIQtjeg.png)

BÃ¼tÃ¼n bu dÃ¶ngÃ¼, gerisin geriye uygulamayÄ± besliyor ve client treeâ€™si bozulmadan sunucu tarafÄ±ndaki gÃ¼ncellemeler istemciye saÄŸlanmÄ±ÅŸ oluyor. Kodun kendisi deÄŸil, sadece ihtiyaÃ§ olunan meta verinin pure kod olarak deÄŸil de kendisine Ã¶zgÃ¼ bir formatta, bu gibi bir kÃ¼tÃ¼phane niteliÄŸi (feature) iÃ§in HTMLâ€™den daha zengin bir iÃ§erik saÄŸlanmÄ±ÅŸ oluyor.

Daha birÃ§ok Ã¶rnek verilebilir ve bu gibi bir featureâ€™Ä±n nasÄ±l geliÅŸtirildiÄŸine deep-dive yukarÄ±daki linklerden faydalanarak detaylÄ±ca girebilirsiniz. Ne de olsa kod geliÅŸtirmenin yazmaktan Ã§ok kod okumaktan ibaret olmasÄ± gibi [bir](https://www.folklore.org/StoryView.py?project=Macintosh&story=Negative_2000_Lines_Of_Code.txt) [durum](https://eksisozluk.com/metreyle-yazilim-satmak--3297121) var. ğŸ¤¦ğŸ»â€â™‚ï¸

Ã–zetle, React ekibi stream tabanlÄ± bir web iletiÅŸim â€œmodeliâ€ kullanarak sunucu taraflÄ± gÃ¼ncellemeleri clientâ€™a ulaÅŸtÄ±rÄ±p bÃ¼tÃ¼n uygulamanÄ±n gÃ¼ncellenmesini gerÃ§ekleÅŸtirmek istemiÅŸ. GÃ¼nÃ¼mÃ¼z server-side renderingâ€™in saÄŸladÄ±ÄŸÄ± imkanlarÄ±n streamâ€™ler ile â€œaÅŸÄ±larakâ€ sadece Reactâ€™e Ã¶zgÃ¼ bir Ã§Ã¶zÃ¼m geliÅŸtirilmek istenmiÅŸ. HenÃ¼z deneysel bir Ã§alÄ±ÅŸma elbette, gelecek gÃ¼ncellemelerle daha robust bir yapÄ±ya kavuÅŸturulursa ne gibi imkanlar yaratÄ±r diye dÃ¼ÅŸÃ¼ndÃ¼ÄŸÃ¼mde ÅŸunlar aklÄ±ma geliyor:

*   Front-end engineering alanÄ± sunuculara olan ilgisi ile performans ve SEO ihtiyaÃ§larÄ± karÅŸÄ±lanÄ±rken Back-end engineering alanÄ± daha Ã§ok GraphQL gibi araÃ§larla client kÄ±smÄ±na daha Ã§ok kafa yormalarÄ±nÄ±n Ã¶nÃ¼ aÃ§Ä±ldÄ±. Bu da aklÄ±ma geliÅŸtiricilerin bir sÃ¼redir sektÃ¶rdeki geliÅŸmeler ve araÃ§larla daha Ã§ok â€˜middle stackâ€™ gibi bir yerde toparlanÄ±yor olmalarÄ± detayÄ±nÄ± getiriyor. Daha computation / algoritma / talep yoÄŸun yazÄ±lÄ±m geliÅŸtirmenin makine Ã¶ÄŸrenmesi gibi alanlara kaydÄ±ÄŸÄ± gÃ¶rÃ¼ÅŸÃ¼ndeyim. React Server Componentsâ€™Ä±n da bu â€˜middle stackâ€™ alanÄ±nda dolduracaÄŸÄ± yer yine sunucu ile istemciyi bir noktada buluÅŸturmak ve sunucu-bazlÄ± etkileÅŸimi yoÄŸun uygulamalar olacak gibi duruyor. BugÃ¼n [websocket](https://www.wikiwand.com/en/WebSocket)â€™lerin kullanÄ±ldÄ±ÄŸÄ± uygulamalarÄ±n artmasÄ± buna dair kÃ¼Ã§Ã¼k bir detay.
*   Front-end geliÅŸtirme Ã§oktan full-stack bir dÃ¼zeleme Ã§oktan taÅŸÄ±nmÄ±ÅŸtÄ±. Bunu clientâ€™tan direk olarak baÅŸka kaynaklara direk baÄŸlantÄ± kuran ve bÃ¶ylece daha hÄ±zlÄ± uygulama geliÅŸtirmeyi saÄŸlayan birÃ§ok araÃ§ ile deneyimlemiÅŸtik / deneyimliyoruz. Bu nedenle bu ivme, React Server Componentâ€™leri ile daha da artacak.
*   JAMStack entegrasyonu ile headless CMSâ€™lerden feed edilen verilerin statik uygulamalarda interaktivite oranÄ±nÄ± yÃ¼kseltir.
*   Ã‡ok fazla API iletiÅŸimi olan uygulama ortamlarÄ±nda clientâ€™in stabil kalabilmesiyle statik sayfalar Ã¼zerinden kurgulanmÄ±ÅŸ uygulamalarda dinamizm katabilir.
*   Server componentâ€™leri Ã¼zerinden uygulama ortamlarÄ±nndan decouple edilmiÅŸ widgetâ€™lar mobil uygulamalara embed edilebilir. Performans ve [zero-bundle](https://medium.com/899285bed4f44d9299f9597f65bb85e7#bd6ee58f22204adeaa8a7b7df57af5f5) size bu noktadan da bir kazanÃ§ saÄŸlayabilir.
*   Read / Update iÅŸlemlerinin Ã§okÃ§a client â€” sunucu arasÄ±nda iletiÅŸimi gerektiren uygulamalarda tek bir component ile en gÃ¼ncel verinin her iki layerâ€™da da gÃ¼ncel kalmasÄ± saÄŸlanabilir. Ã–rnek, Ã¼rÃ¼nlerin / ÅŸirketlerin / topluluklarÄ±n katÄ±lÄ±mcÄ± dÃ¶kÃ¼mantasyon uygulamalarÄ±, e-ticarette Ã¼rÃ¼n detay sayfalarÄ±nÄ±n yorum ve oylama sayfalarÄ±, vb. gibi kullanÄ±m alanlarÄ± akla gelebilir.
*   Lazy-loaded componentâ€™ler sunucu tarafÄ±nda code-splitting saÄŸlayabilir.
*   React frameworkâ€™leri ya da geliÅŸtirme araÃ§larÄ± iÃ§in yeni bir geliÅŸme alanÄ± Ã§Ä±karÄ±r. Mesela ÅŸu andan Next.jsâ€™e bir [entegrasyonun](https://medium.com/899285bed4f44d9299f9597f65bb85e7#d5135598b870470a902efab680d356e5) [geleceÄŸini](https://medium.com/899285bed4f44d9299f9597f65bb85e7#526edb678a3943c397f936174cb65926) tahmin edebiliriz. Zaten [hackernews postâ€™u](https://news.ycombinator.com/item?id=25499171)nda de meta-frameworkâ€™lerin zaten baÅŸardÄ±klarÄ± iÅŸi daha da iyileÅŸtirmek olduÄŸu belirtiliyor.
*   React componentâ€™lerinin onceden uygulamalarda paylaÅŸtÄ±ÄŸÄ± roller (datepicker, media, vs.) Ã¼zerinden tanÄ±mlÄ±yorduk. Åimdi bir de componentâ€™lerin server/client versiyonlarÄ± geliÅŸtirilmeye baÅŸlanabilir. â€˜react-server-neguzelolduâ€™ ya da â€˜react-client-css-animationâ€™ gibi standalone componentâ€™lerin npmâ€™e publish edildiÄŸini gÃ¶rebiliriz. [Burada](https://medium.com/899285bed4f44d9299f9597f65bb85e7#45874eb859e04904b862a3e1a41b407e) belirtilmiÅŸ mesela. Benim favorilerim [bunlar](https://www.youtube.com/watch?v=PI5wz2pwXIg&ab_channel=JSConf) bu arada ğŸ˜‚

BÃ¼tÃ¼n bunlar bir yana, bu gibi bir featureâ€™Ä± React gibi kullanÄ±m alanÄ± oldukÃ§a artmÄ±ÅŸ bir kÃ¼tÃ¼phaneye entegre etmek zaman alacaktÄ±r. UmarÄ±m geliÅŸmelerin ne olacaÄŸÄ± ilerleyen aylarda belli olur, bu alandaki geliÅŸimler diÄŸer kÃ¼tÃ¼phane ya da frameworkâ€™lere de zaten Ã§oktan ilgisini yeterince Ã§ekmiÅŸ daha â€œmiddle stackâ€ Ã§Ã¶zÃ¼mlere yol aÃ§ar.

Zaman ayÄ±rÄ±p okuduÄŸunuz iÃ§in teÅŸekkÃ¼rler. Geri bildirimlerinizi sabÄ±rsÄ±zlÄ±kla bekliyorum. ğŸ‘‹